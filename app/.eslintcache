[{"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\index.js":"1","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\App.js":"2","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\NotFound.js":"3","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\TeamsView.js":"4","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\MatchesView.js":"5","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\TeamView.js":"6","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\MatchView.js":"7","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\serviceWorker.js":"8","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Alert.js":"9","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Form.js":"10","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Table.js":"11","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\PageHeader.js":"12","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Select.js":"13","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Input.js":"14","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Service.js":"15","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\FormGroup.js":"16"},{"size":1243,"mtime":1607074969406,"results":"17","hashOfConfig":"18"},{"size":710,"mtime":1607078142480,"results":"19","hashOfConfig":"18"},{"size":100,"mtime":1606895122868,"results":"20","hashOfConfig":"18"},{"size":1967,"mtime":1606917655683,"results":"21","hashOfConfig":"18"},{"size":2427,"mtime":1606895122865,"results":"22","hashOfConfig":"18"},{"size":2403,"mtime":1607075048858,"results":"23","hashOfConfig":"18"},{"size":5134,"mtime":1607074969400,"results":"24","hashOfConfig":"18"},{"size":4951,"mtime":1606895122891,"results":"25","hashOfConfig":"18"},{"size":644,"mtime":1607077009745,"results":"26","hashOfConfig":"18"},{"size":336,"mtime":1606895122862,"results":"27","hashOfConfig":"18"},{"size":3645,"mtime":1606895122880,"results":"28","hashOfConfig":"18"},{"size":4059,"mtime":1606917451254,"results":"29","hashOfConfig":"18"},{"size":1319,"mtime":1607074969402,"results":"30","hashOfConfig":"18"},{"size":1063,"mtime":1607078537216,"results":"31","hashOfConfig":"18"},{"size":14501,"mtime":1607078066967,"results":"32","hashOfConfig":"18"},{"size":660,"mtime":1606895122863,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"1gcy4v2",{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"36"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"36"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"36"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"62","usedDeprecatedRules":"36"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"67","messages":"68","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69","usedDeprecatedRules":"36"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\index.js",[],["72","73"],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\App.js",[],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\NotFound.js",[],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\TeamsView.js",[],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\MatchesView.js",[],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\TeamView.js",["74"],"import React from \"react\";\nimport service from \"./Service\";\nimport Form from \"./Form\";\nimport PageHeader from \"./PageHeader\";\n\nexport default class TeamView extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      /*team: {\n        name: \"\"\n      },*/\n      errors: []\n    };\n    //this.save = this.save.bind(this);\n    //this.onChange = this.onChange.bind(this);\n  }\n\n  /*async componentDidMount() {\n    try {\n      if (this.props.match.params.id) {\n        let team = await service.readEntity(\n          \"team/\" + this.props.match.params.id\n        );\n\n        this.setState({\n          team: team\n        });\n      } else {\n        this.setState({\n          team: {\n            name: \"\"\n          }\n        });\n      }\n    } catch (e) {\n      if (e instanceof NotFoundError) {\n        this.props.history.push(\"/not-found\");\n      } else {\n        this.setState({\n          errors: [e]\n        });\n      }\n    }\n  }\n\n  async save(event) {\n    try {\n      event.preventDefault();\n\n      let team;\n      if (this.props.match.params.id) {\n        team = await service.updateEntity(\n          \"team/\" + this.state.team.id,\n          this.state.team\n        );\n      } else {\n        team = await service.createEntity(\"teams\", this.state.team);\n        this.props.history.replace(\"/team/\" + team.id);\n      }\n    } catch (e) {\n      if (e instanceof NotFoundError) {\n        this.props.history.push(\"/not-found\");\n      }\n      this.setState({\n        errors: [e]\n      });\n    }\n  }\n\n  onChange(event) {\n    try {\n      this.setState({\n        team: Object.assign({}, this.state.team, {\n          name: event.target.value\n        })\n      });\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n  }*/\n\n  render() {\n    let errors = this.state.errors,\n      title;\n    try {\n      title = this.props.match.params.id\n        ? \"Verein #\" + this.props.match.params.id\n        : \"Neues Spiel\";\n    } catch (e) {\n      errors = [e];\n    }\n\n    return (\n      <div>\n        <PageHeader title={title} history={this.props.history} />\n        <Form\n          meta=\"/team\"\n          operation={this.props.match.params.id ? \"update\" : \"create\"}\n          errors={errors}\n          value={\n            this.props.match.params.id\n              ? \"/team/\" + this.props.match.params.id\n              : \"/teams\"\n          }\n        />\n      </div>\n    );\n  }\n}\n","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\MatchView.js",["75"],"import React from \"react\";\nimport service from \"./Service\";\nimport Form from \"./Form\";\nimport Select from \"./Select\";\nimport Input from \"./Input\";\nimport PageHeader from \"./PageHeader\";\n\nexport default class MatchView extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      match: {\n        gameDay: \"\",\n        host: {\n          goals: 0\n        },\n        guest: {\n          goals: 0\n        }\n      },\n      errors: []\n    };\n    this.save = this.save.bind(this);\n    this.onSelectTeam = this.onSelectTeam.bind(this);\n    this.onChangeGoal = this.onChangeGoal.bind(this);\n    this.onChangeGameDay = this.onChangeGameDay.bind(this);\n  }\n\n  async componentDidMount() {\n    try {\n      this.setState({\n        errors: []\n      });\n\n      if (this.props.match.params.id) {\n        this.setState({\n          match: await service.readEntity(\n            \"/match/\" + this.props.match.params.id\n          )\n        });\n      }\n    } catch (e) {\n      if (e.httpCode == 401) {\n        this.props.history.push(\"/not-found\");\n      } else {\n        this.setState(state => ({\n          errors: [e]\n        }));\n      }\n    }\n  }\n\n  async save(event) {\n    try {\n      let match;\n      event.preventDefault();\n\n      this.setState({\n        errors: [],\n        sent: true\n      });\n\n      if (this.props.match.params.id) {\n        match = await service.updateEntity(\n          \"/match/\" + this.state.match.id,\n          this.state.match\n        );\n      } else {\n        match = await service.createEntity(\"/matches\", this.state.match);\n\n        this.props.history.push(\"/match/\" + match.id);\n      }\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n  }\n\n  onSelectTeam(event, team) {\n    try {\n      let newMatch = Object.assign({}, this.state.match);\n\n      if (event.target.id === \"cmbTeam1\") {\n        newMatch.host = Object.assign({}, this.state.match.host, team);\n      } else {\n        newMatch.guest = Object.assign({}, this.state.match.guest, team);\n      }\n\n      this.setState({\n        match: newMatch,\n        sent: false\n      });\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n  }\n\n  onChangeGameDay(event) {\n    try {\n      this.setState({\n        match: Object.assign({}, this.state.match, {\n          gameDay: event.target.value\n        }),\n        sent: false\n      });\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n  }\n\n  onChangeGoal(event) {\n    try {\n      let newMatch = Object.assign({}, this.state.match);\n\n      if (event.target.id === \"txtGoals1\") {\n        newMatch.host.goals = Number.isInteger(event.target.value)\n          ? +event.target.value\n          : event.target.value;\n      } else {\n        newMatch.guest.goals = Number.isInteger(event.target.value)\n          ? +event.target.value\n          : event.target.value;\n      }\n\n      this.setState({\n        match: newMatch,\n        sent: false\n      });\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n  }\n\n  render() {\n    let errors = this.state.errors,\n      title;\n\n    try {\n      title = this.state.match.id\n        ? \"Spiel #\" + this.state.match.id\n        : \"Neues Spiel\";\n    } catch (e) {\n      errors = [e];\n    }\n\n    return (\n      <div>\n        <PageHeader title={title} history={this.props.history} />\n\n        <Form onSubmit={this.save} errors={errors} validated={this.state.sent}>\n          <Input\n            id=\"txtGameday\"\n            meta=\"/match/gameDay\"\n            onChange={this.onChangeGameDay}\n            value={this.state.match.gameDay}\n            type=\"date\"\n            errors={errors.filter(\n              error => error.field === \"gameDay\"\n            )}\n          />\n          <Select\n            id=\"cmbTeam1\"\n            onChange={this.onSelectTeam}\n            value={this.state.match.host.id}\n            meta=\"/match/host\"\n            errors={errors.filter(\n              error => error.field === \"host.id\"\n            )}\n          />\n          <Select\n            id=\"cmbTeam2\"\n            meta=\"/match/guest\"\n            onChange={this.onSelectTeam}\n            value={this.state.match.guest.id}\n            errors={errors.filter(\n              error => error.field === \"guest.id\"\n            )}\n          />\n          <div className=\"form-row\">\n            <Input\n              id=\"txtGoals1\"\n              onChange={this.onChangeGoal}\n              value={this.state.match.host.goals}\n              meta=\"/participant/goals\"\n              type=\"number\"\n              errors={errors.filter(\n                error =>\n                  error.field === \"host.goals\"\n              )}\n              inline={true}\n            />\n            <Input\n              id=\"txtGoals2\"\n              onChange={this.onChangeGoal}\n              value={this.state.match.guest.goals}\n              meta=\"/participant/goals\"\n              type=\"number\"\n              errors={errors.filter(\n                error =>\n                  error.field === \"guest.goals\"\n              )}\n              inline={true}\n            />\n          </div>\n        </Form>\n      </div>\n    );\n  }\n}\n","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\serviceWorker.js",[],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Alert.js",[],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Form.js",[],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Table.js",["76"],"import React from \"react\";\n\nexport default class Table extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      selection: {}\n    };\n\n    this.toggleSelection = this.toggleSelection.bind(this);\n    this.delete = this.delete.bind(this);\n  }\n\n  toggleSelection(event) {\n    let newState = {\n      selection: Object.assign({}, this.state.selection)\n    };\n\n    newState.selection[event.target.id] = {};\n\n    if (\n      this.state.selection[event.target.id] &&\n      this.state.selection[event.target.id].selected\n    ) {\n      delete newState.selection[event.target.id];\n    } else {\n      newState.selection[event.target.id].selected = true;\n    }\n\n    this.setState(newState);\n  }\n\n  delete() {\n    let toDeleteIds = [],\n      toDeleteItems = [];\n\n    let keys = Object.keys(this.state.selection);\n\n    keys.forEach(key => {\n      if (this.state.selection[key].selected) {\n        toDeleteIds.push(+key);\n        toDeleteItems.push(this.props.rows.find(item => item.id === +key));\n      }\n    });\n\n    this.props.delete(toDeleteIds, toDeleteItems).then(() => {\n      this.setState({\n        selection: {}\n      });\n    });\n  }\n\n  getContent(row, column) {\n    let value;\n\n    if (column.type === \"date\") {\n      value = new Date(row[column.name]).toLocaleDateString();\n    } else if (typeof column.name === \"function\") {\n      value = column.name(row);\n    } else {\n      value = row[column.name];\n    }\n\n    let content = column.navigation ? (\n      <a id={row.id.toString()} onClick={column.navigation} href=\"#\">\n        {value}\n      </a>\n    ) : (\n      value\n    );\n\n    if (column.name === \"id\") {\n      return (\n        <th id={row.id.toString()} scope=\"row\" key={column.id}>\n          {content}\n        </th>\n      );\n    } else {\n      return (\n        <td id={row.id.toString()} key={column.id}>\n          {content}\n        </td>\n      );\n    }\n  }\n\n  render() {\n    let rows = !this.props.rows ? (\n      <tr>\n        <td colSpan={this.props.columns.length} className=\"text-center\">keine Daten</td>\n      </tr>\n    ) : (\n      this.props.rows &&\n      this.props.rows.map(row => {\n        let selected =\n            this.state.selection[row.id.toString()] &&\n            this.state.selection[row.id.toString()].selected,\n          attributes = {\n            className: selected ? \"table-danger\" : \"\"\n          };\n\n        let cells =\n          this.props.columns &&\n          this.props.columns.map(column => this.getContent(row, column));\n\n        return (\n          <tr\n            {...attributes}\n            key={row.id.toString()}\n            onClick={this.toggleSelection}\n          >\n            {cells}\n          </tr>\n        );\n      })\n    );\n    return (\n      <table className=\"table table-bordered table-hover\">\n        <thead>\n          <tr>\n            <th colSpan={this.props.columns.length + 1} className=\"text-right\">\n              <button className=\"btn btn-secondary\" onClick={this.props.create}>\n                Neu\n              </button>\n              <button\n                className=\"btn btn-danger\"\n                onClick={this.delete}\n                disabled={Object.keys(this.state.selection).length === 0}\n              >\n                Löschen\n              </button>\n            </th>\n          </tr>\n          <tr>\n            {this.props.columns &&\n              this.props.columns.map(column => {\n                return (\n                  <th key={column.id} scope=\"col\">\n                    {column.label}\n                  </th>\n                );\n              })}\n          </tr>\n        </thead>\n        <tbody>{rows}</tbody>\n      </table>\n    );\n  }\n}\n","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\PageHeader.js",["77","78","79"],"import React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport Alert from \"./Alert\";\nimport service from \"./Service\";\n\nexport default class PageHeader extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      collapsed: true,\n      collapsing: false,\n      errors: []\n    };\n\n    this.toggleMenu = this.toggleMenu.bind(this);\n  }\n\n  componentDidMount() {\n    try {\n      this.setState({\n        height: this.divElement.clientHeight\n      });\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n  }\n\n  toggleMenu() {\n    try {\n      this.setState({\n        collapsing: true\n      });\n\n      setTimeout(() => {\n        this.setState((state, props) => ({\n          collapsed: !state.collapsed,\n          collapsing: false\n        }));\n      }, 350);\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n  }\n\n  async download() {\n    try {\n      let data = await service.readAll();\n      let dataUrl =\n          \"data:text/json;charset=utf8,\" +\n          encodeURIComponent(JSON.stringify(data)),\n        aDownload = document.getElementById(\"downloadDummy\");\n\n      aDownload.setAttribute(\"href\", dataUrl);\n      aDownload.setAttribute(\"download\", \"data.json\");\n\n      aDownload.click();\n    } catch (error) {\n      this.setState({\n        errors: [error]\n      });\n    }\n  }\n\n  render() {\n    let style = {},\n      btnBack;\n    try {\n      btnBack =\n        this.props.history.length &&\n        this.props.history.location.pathname !== \"/\" ? (\n          <button\n            className=\"btn btn-link\"\n            onClick={() => this.props.history.goBack()}\n          >\n            Zurück{\" \"}\n          </button>\n        ) : null;\n\n      if (this.state.collapsed) {\n        style.height = this.state.height;\n      }\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n    return (\n      <div className=\"row\">\n        <div className=\"col\">\n          <nav className=\"navbar navbar-expand-lg navbar-light bg-light\">\n            <Link className=\"navbar-brand\" to=\"/\">\n              {this.props.title}\n            </Link>\n            <button\n              onClick={this.toggleMenu}\n              className={\n                this.state.collapsed\n                  ? \"navbar-toggler collapsed\"\n                  : \"navbar-toggler\"\n              }\n              type=\"button\"\n              data-toggle=\"collapse\"\n              data-target=\"#navbarSupportedContent\"\n              aria-controls=\"navbarSupportedContent\"\n              aria-expanded={this.state.collapsed ? \"false\" : \"true\"}\n              aria-label=\"Toggle navigation\"\n            >\n              <span className=\"navbar-toggler-icon\" />\n            </button>\n\n            <div\n              className={\n                this.state.collapsing\n                  ? \"navbar-collapse collapsing\"\n                  : this.state.collapsed\n                  ? \"navbar-collapse collapse\"\n                  : \"navbar-collapse collapse show\"\n              }\n              {...style}\n              id=\"navbarSupportedContent\"\n            >\n              <ul\n                className=\"navbar-nav mr-auto\"\n                ref={divElement => {\n                  this.divElement = divElement;\n                }}\n              >\n                <li className=\"nav-item\">\n                  <Link className=\"nav-link\" to=\"/teams\">\n                    Vereine\n                  </Link>\n                </li>\n                <li className=\"nav-item\">\n                  <Link className=\"nav-link\" to=\"/matches\">\n                    Spiele\n                  </Link>\n                </li>\n                <li className=\"nav-item\">\n                  <a className=\"nav-link\" onClick={this.download}>\n                    Exportieren\n                  </a>\n                  <a id=\"downloadDummy\" style={{ display: \"none\" }} />\n                </li>\n              </ul>\n            </div>\n          </nav>\n          {btnBack}\n          <Alert messages={this.state.errors} />\n        </div>\n      </div>\n    );\n  }\n}\n","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Select.js",[],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Input.js",[],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Service.js",["80"],"class Service {\n  constructor() {\n    this.data = {\n      teams: [\n        {\n          id: 1,\n          name: \"Mönchen Gladbach\"\n        },\n        {\n          id: 2,\n          name: \"1. FC Köln\"\n        },\n        {\n          id: 3,\n          name: \"Bayer Leverkusen\"\n        },\n        {\n          id: 4,\n          name: \"FC Bayern\"\n        },\n        {\n          id: 5,\n          name: \"Schalke\"\n        },\n        {\n          id: 6,\n          name: \"Vfb\"\n        },\n        {\n          id: 7,\n          name: \"Freiburg\"\n        },\n        {\n          id: 8,\n          name: \"SGE\"\n        },\n        {\n          id: 9,\n          name: \"Arminia\"\n        }\n      ],\n      matches: [\n        {\n          id: 1,\n          host: {\n            id: 4,\n            goals: 8,\n            name: \"FC Bayern\"\n          },\n          guest: {\n            id: 5,\n            goals: 0,\n            name: \"Schalke\"\n          },\n          gameDay: \"2020-01-01\"\n        },\n        {\n          id: 2,\n          host: {\n            id: 6,\n            goals: 2,\n            name: \"Vfb\"\n          },\n          guest: {\n            id: 7,\n            goals: 3,\n            name: \"Freiburg\"\n          },\n          gameDay: \"2020-02-01\"\n        },\n        {\n          id: 3,\n          host: {\n            id: 8,\n            goals: 1,\n            name: \"SGE\"\n          },\n          guest: {\n            id: 9,\n            goals: 1,\n            name: \"Arminia\"\n          },\n          gameDay: \"2020-03-01\"\n        }\n      ]\n    };\n\n    this.metadata = {\n      paths: [\n        {\n          name: \"/team/:id\",\n          type: \"team\",\n          collection: \"teams\"\n        },\n        {\n          name: \"/teams\",\n          type: \"team\",\n          sort: this.sortTeams,\n          collection: \"teams\"\n        },\n        {\n          name: \"/match/:id\",\n          type: \"match\",\n          validate: this.validateMatch,\n          collection: \"matches\"\n        },\n        {\n          name: \"/matches\",\n          type: \"match\",\n          sort: this.sortMatch,\n          collection: \"matches\"\n        }\n      ],\n      types: [\n        {\n          name: \"match\",\n          properties: [\n            {\n              name: \"id\",\n              type: \"number\",\n              label: \"#\",\n              isKey: true,\n              autoIncrement: true\n            },\n            {\n              name: \"gameDay\",\n              type: \"date\",\n              label: \"Spieltag\",\n              required: true\n            },\n            {\n              name: \"host\",\n              type: \"participant\",\n              label: \"Gastgeber\",\n              required: true,\n              valueList: {\n                path: \"/teams\",\n                id: \"id\",\n                value: \"name\"\n              }\n            },\n            {\n              name: \"guest\",\n              type: \"participant\",\n              label: \"Gast\",\n              required: true,\n              valueList: {\n                path: \"/teams\",\n                id: \"id\",\n                value: \"name\"\n              }\n            }\n          ]\n        },\n        {\n          name: \"team\",\n          form: [\n            {\n              path: \"name\",\n              meta: \"/team/name\",\n              type: \"TextBox\"\n            }\n          ],\n          properties: [\n            {\n              name: \"$uri\",\n              value: \"/team/{id}\"\n            },\n            {\n              name: \"id\",\n              type: \"number\",\n              label: \"#\",\n              isKey: true,\n              autoIncrement: true\n            },\n            {\n              name: \"name\",\n              type: \"string\",\n              label: \"Name\",\n              isName: true,\n              required: true\n            }\n          ]\n        },\n        {\n          name: \"participant\",\n          properties: [\n            {\n              name: \"id\",\n              type: \"number\",\n              required: true\n            },\n            {\n              name: \"name\",\n              type: \"string\",\n              required: true\n            },\n            {\n              name: \"goals\",\n              type: \"number\",\n              label: \"Tore\",\n              min: 0,\n              required: true\n            }\n          ]\n        }\n      ]\n    };\n/*\n    this.batch = [];\n    this.interrupt = 0;\n    this.pending = 0;\n    this.executeBatch = this.executeBatch.bind(this);*/\n  }\n\n  /*startBatch() {\n    if (!this.pending) {\n      this.pending = setTimeout(this.executeBatch, this.interrupt);\n    }\n  }\n\n  executeBatch() {\n    this.batch.forEach(batchRequest => {\n      try {\n        batchRequest.resolve(result);\n      } catch (e) {\n        batchRequest.reject(e);\n      }\n    });\n  }*/\n\n  post() {}\n\n  createEntity(path, data) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.batch.push({\n          method: \"post\",\n          path: path,\n          resolve: resolve,\n          reject: reject\n        });\n        this.startBatch();\n\n        let metadataPath = this.getMetaPath(path),\n          collection = this.getCollection(path, metadataPath);\n\n        if (!path) {\n          throw new Error(\"Pfad nicht angegeben\");\n        }\n\n        this.determineEntity(metadataPath, collection, \"create\", data);\n        this.validateEntity(metadataPath, collection, \"create\", data);\n\n        collection.push(Object.assign({}, data));\n        resolve(data);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  readEntity(path) {\n    return new Promise((resolve, reject) => {\n      try {\n        let metadataPath = this.getMetaPath(path),\n          collection = this.getCollection(path, metadataPath);\n\n        if (!path) {\n          throw new Error(\"Pfad nicht angegeben\");\n        }\n\n        let result = collection.find(entity =>\n          this.entityEquals(path, metadataPath, entity)\n        );\n\n        if (result) {\n          resolve(Object.assign({}, result));\n        } else {\n          let e = new Error(`Entität nicht gefunden`);\n          e.httpStatus = 401.\n          throw e;\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  readEntities(path) {\n    return new Promise((resolve, reject) => {\n      try {\n        let metadataPath = this.getMetaPath(path),\n          collection = this.getCollection(path, metadataPath);\n\n        if (!path) {\n          throw new Error(\"Pfad nicht angegeben\");\n        }\n\n        let result = collection.filter(entity =>\n          this.entityEquals(path, metadataPath, entity)\n        );\n\n        if (result && !result.length) {\n          resolve(result);\n        }\n\n        if (metadataPath.sort) {\n          result = result.sort(metadataPath.sort);\n        }\n\n        resolve(result.map(entity => Object.assign({}, entity)));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  metaRecursiv(metadata, parts) {\n    if (!parts.length) {\n      return metadata;\n    }\n    let property = metadata.properties.find(\n      property => property.name === parts[0]\n    );\n\n    if (parts.length === 1) {\n      return property;\n    } else {\n      let type = this.metadata.type.find(type => type.name === property.type);\n      parts.splice(1);\n\n      if (!type) {\n        throw new Error(`Pfad \"${parts[0]}\" nicht auflösbar`);\n      } else {\n        return this.metaRecursiv(type, parts);\n      }\n    }\n  }\n\n  readMetadata(path) {\n    return new Promise((resolve, reject) => {\n      try {\n        let parts = path.split(\"/\").filter(part => part),\n          result;\n        if (!parts.length) {\n          throw new Error(\"Metadatenpfad nicht angegeben\");\n        }\n\n        result = this.metadata.types.find(type => type.name === parts[0]);\n        if (!result) {\n          throw new Error(`Pfad \"${parts[0]}\" konnte nicht aufgelöst werden`);\n        }\n\n        result = this.metaRecursiv(result, parts.splice(1));\n\n        resolve(result);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  updateEntity(path, data) {\n    return new Promise((resolve, reject) => {\n      try {\n        let metadataPath = this.getMetaPath(path),\n          collection = this.getCollection(path, metadataPath);\n\n        if (!path) {\n          throw new Error(\"Pfad nicht angegeben\");\n        }\n\n        let result = collection.find(entity =>\n          this.entityEquals(path, metadataPath, entity)\n        );\n\n        if (result) {\n          Object.assign(result, data);\n\n          this.determineEntity(metadataPath, collection, \"update\", result);\n          this.validateEntity(metadataPath, collection, \"update\", result);\n\n          resolve(Object.assign({}, result));\n        } else {\n          let e = new Error('Nicht gefunden');\n          e.httpStatus = 401.\n          throw e;\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  deleteEntity(path) {\n    return new Promise((resolve, reject) => {\n      try {\n        let metadataPath = this.getMetaPath(path),\n          collection = this.getCollection(path, metadataPath);\n\n        if (!path) {\n          throw new Error(\"Pfad nicht angegeben\");\n        }\n\n        let result = collection.find(entity =>\n          this.entityEquals(path, metadataPath, entity)\n        );\n\n        if (result) {\n          let index = collection.indexOf(result);\n\n          collection.splice(index, 1);\n          resolve();\n        } else {\n          let e = new Error('Nicht gefunden');\n          e.httpStatus = 401.\n          throw e;\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  getMetaPath(path) {\n    return this.metadata.paths.find(metaPath => {\n      // /team/:id\n      let metaRegex = metaPath.name.replace(/:\\w+/g, \"([^/]+)\"),\n        matches = path.match(metaRegex),\n        paramMatches = metaPath.name.match(/:\\w+/g);\n      // /team/([^/]+)\n      // [ \"/team/:id\", \":id\" ]\n      // [ \":id\" ]\n\n      //Filter auf untypisierten Regex fehlgeschlagen\n      if (!matches || !matches.length) {\n        return false;\n      }\n\n      if (!paramMatches) {\n        //keine parameter vorhanden\n        return true;\n      }\n\n      // typisierten Regex erstellen\n      metaRegex = metaPath.name;\n      paramMatches.forEach(match => {\n        let type = this.metadata.types.find(\n          type => type.name === metaPath.type\n        );\n\n        let property = type.properties.find(property => {\n            return property.name === match.substring(1);\n          }),\n          paramRegex;\n        switch (property.type) {\n          case \"number\":\n            paramRegex = \"([0-9]+)\";\n            break;\n\n          case \"string\":\n            paramRegex = \"([^/]+)\";\n        }\n        metaRegex = metaRegex.replace(\":\" + property.name, paramRegex);\n      });\n\n      // gegen typisiertes Regex testen\n      matches = path.match(metaRegex);\n\n      //Filter auf typisierten Regex\n      if (!matches || !matches.length) {\n        return false;\n      }\n\n      return matches[0] === path;\n    });\n  }\n\n  getCollection(path, metadataPath) {\n    if (!metadataPath) {\n      let e = new Error(`Ressource \"${path}\" nicht gefunden`);\n      e.httpStatus = 401.\n      throw e;\n    }\n\n    return this.data[metadataPath.collection];\n  }\n\n  entityEquals(path, metadataPath, entity) {\n    //Pfad aus der Entität erstellen udn mit dem übergebenen Pfad abgleichen\n    let type = this.metadata.types.find(\n        type => type.name === metadataPath.type\n      ),\n      entityPath = metadataPath.name;\n\n    // Wenn keine Parameter definiert ist, dann ist alles ein Treffer\n    if (metadataPath.name.search(\":\") === -1) {\n      return true;\n    }\n\n    type.properties.forEach(\n      property =>\n        (entityPath = entityPath.replace(\n          \":\" + property.name,\n          entity[property.name]\n        ))\n    );\n\n    return path === entityPath;\n  }\n\n  determineEntity(metadataPath, collection, operation, data) {\n    let type = this.metadata.types.find(\n        type => type.name === metadataPath.type\n      ),\n      uri = type.properties.find(property => property.name === \"$uri\").value;\n    alert(uri);\n\n    type.properties.forEach(\n      property =>\n        (uri = uri.replace(\"{\" + property.name + \"}\", data[property.name]))\n    );\n    data[\"$uri\"] = uri;\n\n    if (operation === \"create\") {\n      type.properties.forEach(property => {\n        if (property.autoIncrement) {\n          let maxValue = -1;\n\n          collection.forEach(entity => {\n            maxValue =\n              entity[property.name] > maxValue\n                ? entity[property.name]\n                : maxValue;\n          });\n\n          data[property.name] = ++maxValue;\n        }\n      });\n    }\n\n    if (type.determine) {\n      type.determine(metadataPath, collection, operation, data);\n    }\n  }\n\n  validateProperties(property, data, error) {\n    error.errors = error.errors ?? [];\n\n    if (property.required && !data[property.name]) {\n      let e = new Error(\"Das ist ein Pflichtfeld\");\n      e.field = property.name;\n      error.errors.push(e);\n    }\n\n    //rekursiver Aufruf für die Validierung\n    if (this.metadata.types[property.type] && data[property.name]) {\n      let type = this.metadata.types[property.type];\n\n      type.properties.forEach(property =>\n        this.validateProperties(property, data[property.name], error)\n      );\n    }\n  }\n\n  validateEntity(metadataPath, collection, operation, data) {\n    let error = new Error(),\n      type = this.metadata.types.find(type => type.name === metadataPath.type);\n\n    type.properties.forEach(property =>\n      this.validateProperties(property, data, error)\n    );\n\n    switch (error.errors.length) {\n      case 0:\n        break;\n      case 1:\n        throw error.errors[0];\n      default:\n        throw error;\n    }\n\n    if (type.validate) {\n      type.validate(metadataPath, collection, operation, data);\n    }\n  }\n\n  sortTeams(team1, team2) {\n    if (team1.name > team2.name) {\n      return 1;\n    }\n    if (team1.name < team2.name) {\n      return -1;\n    }\n\n    return 0;\n  }\n\n  validateMatch(metadataPath, collection, operation, data) {\n    if (data.host.id === data.guest.id) {\n      let e = new Error(\"Wählen Sie zwei unterschiedliche Teams aus\");\n      e.field = \"guest.id\";\n      throw e;\n    }\n  }\n\n  sortMatch(a, b) {\n    if (a.gameDay > b.gameDay) {\n      return 1;\n    }\n    if (a.gameDay < b.gameDay) {\n      return -1;\n    }\n    if (a.host.name > b.host.name) {\n      return 1;\n    }\n    if (a.guest.name < b.guest.name) {\n      return -1;\n    }\n\n    return 0;\n  }\n\n  readAll() {\n    return new Promise((resolve, reject) => {\n      resolve(this.data);\n    });\n  }\n}\n\nconst service = new Service();\n\nexport default service;\n","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\FormGroup.js",[],{"ruleId":"81","replacedBy":"82"},{"ruleId":"83","replacedBy":"84"},{"ruleId":"85","severity":1,"message":"86","line":2,"column":8,"nodeType":"87","messageId":"88","endLine":2,"endColumn":15},{"ruleId":"89","severity":1,"message":"90","line":44,"column":22,"nodeType":"91","messageId":"92","endLine":44,"endColumn":24},{"ruleId":"93","severity":1,"message":"94","line":66,"column":7,"nodeType":"95","endLine":66,"endColumn":70},{"ruleId":"93","severity":1,"message":"96","line":144,"column":19,"nodeType":"95","endLine":144,"endColumn":67},{"ruleId":"97","severity":1,"message":"98","line":147,"column":19,"nodeType":"95","endLine":147,"endColumn":71},{"ruleId":"93","severity":1,"message":"96","line":147,"column":19,"nodeType":"95","endLine":147,"endColumn":71},{"ruleId":"99","severity":1,"message":"100","line":457,"column":9,"nodeType":"101","messageId":"102","endLine":464,"endColumn":10},"no-native-reassign",["103"],"no-negated-in-lhs",["104"],"no-unused-vars","'service' is defined but never used.","Identifier","unusedVar","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","jsx-a11y/anchor-has-content","Anchors must have content and the content must be accessible by a screen reader.","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","no-global-assign","no-unsafe-negation"]