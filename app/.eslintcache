[{"C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\index.js":"1","C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\Prediction.js":"2","C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\NotFound.js":"3","C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\serviceWorker.js":"4","C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\App.js":"5","C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\Form.js":"6","C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\PageHeader.js":"7","C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\Select.js":"8","C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\Alert.js":"9","C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\FormGroup.js":"10","C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\Service.js":"11","C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\Setup.js":"12"},{"size":973,"mtime":1608065972682,"results":"13","hashOfConfig":"14"},{"size":2198,"mtime":1607897631198,"results":"15","hashOfConfig":"14"},{"size":104,"mtime":1603284762261,"results":"16","hashOfConfig":"14"},{"size":4951,"mtime":1607014096571,"results":"17","hashOfConfig":"14"},{"size":2767,"mtime":1608065842895,"results":"18","hashOfConfig":"14"},{"size":336,"mtime":1607014096547,"results":"19","hashOfConfig":"14"},{"size":4059,"mtime":1607014096554,"results":"20","hashOfConfig":"14"},{"size":1412,"mtime":1607889297113,"results":"21","hashOfConfig":"14"},{"size":644,"mtime":1607283376079,"results":"22","hashOfConfig":"14"},{"size":660,"mtime":1607014096549,"results":"23","hashOfConfig":"14"},{"size":14501,"mtime":1607283376102,"results":"24","hashOfConfig":"14"},{"size":1422,"mtime":1608060830389,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1bzr7mu",{"filePath":"28","messages":"29","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30","usedDeprecatedRules":"31"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38","usedDeprecatedRules":"31"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"31"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"53"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},"C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\index.js",[],"C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\Prediction.js",["56","57"],"import React from \"react\";\nimport PageHeader from \"./PageHeader\";\n\nexport default class Prediction extends React.Component {\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            prediction: {\n                team1: {},\n                team2: {},\n                \"final-score\": {\n                    team1: {},\n                    team2: {}\n                }\n            },\n            errors: []\n        };\n\n    }\n\n    async componentDidMount() {\n        try {\n            let response, teams, error,\n              sort = (a,b) => {\n                        let key1 = Object.keys(a)[0],\n                            key2 = Object.keys(b)[0];\n\n                        return a[key1] - b[key2];\n                      };\n\n            response = await fetch(`/api/prediction/${this.props.match.params.team1}/${this.props.match.params.team2}`);\n\n            if (response.status === 200) {\n                this.setState({\n                    prediction: await response.json()\n                });\n\n            } else {\n                error = await response.text();\n                throw new Error(error);\n            }\n\n        } catch (e) {\n            this.setState({\n                errors: [e]\n            });\n\n        }\n    }\n\n    render() {\n        let draw = this.state.prediction.draw ? <p>ended mit einem Unentschieden({this.state.prediction.draw.probability}%)</p> : null,\n            winner = this.state.prediction.winner ? <p> mit einem Sieg von {this.state.prediction.winner.team.TeamName}({this.state.prediction.winner.probability}%)</p> : null,\n            result = <p>{this.state.prediction[\"final-score\"].team1.goals}({this.state.prediction[\"final-score\"].team1.probability}%) : {this.state.prediction[\"final-score\"].team2.goals}({this.state.prediction[\"final-score\"].team2.probability}%)</p>\n\n        return (\n            <div>\n                <PageHeader history={this.props.history} title=\"Vorhersage\" />\n                <p>Das Spiel</p>\n                <h2>{this.state.prediction.team1.TeamName} : {this.state.prediction.team2.TeamName}</h2>\n                {draw}\n                {winner}\n                {result}\n            </div>\n        );\n    }\n}\n",["58","59"],"C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\NotFound.js",[],"C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\serviceWorker.js",[],"C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\App.js",["60"],"import React from \"react\";\nimport PageHeader from \"./PageHeader\";\nimport Form from \"./Form\";\nimport Select from \"./Select\";\n\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      teams: [],\n      team1: {},\n      team2: {},\n      errors: []\n    };\n\n    this.onSubmit = this.onSubmit.bind(this);\n    this.onSelectTeam = this.onSelectTeam.bind(this);\n  }\n\n  async componentDidMount() {\n    try {\n      let response, teams, error;\n\n      response = await fetch(\"/api/teams\");\n\n      if (response.status === 200) {\n        teams = await response.json();\n\n        this.setState({\n          teams: teams\n        });\n\n      } else if(response.status === 404) {\n        this.props.history.push(\"/setup\");\n\n      } else {\n        error = await response.text();\n        throw new Error(error);\n        \n      }\n\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n\n    }\n  }\n\n  onSelectTeam(event) {\n    try {\n      if (event.target.id === \"cmbTeam1\") {\n        this.setState({\n          team1: this.state.teams.find(team => team.TeamId === +event.target.value)\n        });\n      } else {\n        this.setState({\n          team2: this.state.teams.find(team => team.TeamId === +event.target.value)\n        });\n      }\n\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n  }\n\n  onSubmit(event) {\n    event.preventDefault();\n\n    if (this.state.team1.TeamId != this.state.team2.TeamId) {\n      this.props.history.push(`/prediction/${this.state.team1.TeamId}/${this.state.team2.TeamId}`);\n\n    } else {\n      const message = \"Wählen Sie unterschiedliche Teams\";\n      let e = new Error(message),\n        errors = [e];\n\n      e.field = \"team1\";\n\n      e = new Error(message)\n      e.field = \"team2\";\n      errors.push(e);\n\n      this.setState({\n        errors: errors\n      });\n\n    }\n  }\n\n  render() {\n    let teams = this.state.teams.map(team => ({\n      id: team.TeamId,\n      value: team.TeamName\n    }));\n\n    return (\n      <div>\n        <PageHeader history={this.props.history} title=\"Startseite\" />\n        <Form onSubmit={this.onSubmit} errors={this.state.errors}>\n          <Select\n            id=\"cmbTeam1\"\n            required={true}\n            onChange={this.onSelectTeam}\n            value={this.state.team1.TeamId}\n            errors={this.state.errors.filter(error => error.field === 'team1')}\n            options={teams}\n          />\n          <Select\n            id=\"cmbTeam2\"\n            required={true}\n            onChange={this.onSelectTeam}\n            value={this.state.team2.TeamId}\n            options={teams}\n            errors={this.state.errors.filter(error => error.field === 'team2')}\n            />\n        </Form>\n      </div>\n    );\n  }\n}\n","C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\Form.js",[],"C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\PageHeader.js",["61","62","63"],"import React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport Alert from \"./Alert\";\nimport service from \"./Service\";\n\nexport default class PageHeader extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      collapsed: true,\n      collapsing: false,\n      errors: []\n    };\n\n    this.toggleMenu = this.toggleMenu.bind(this);\n  }\n\n  componentDidMount() {\n    try {\n      this.setState({\n        height: this.divElement.clientHeight\n      });\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n  }\n\n  toggleMenu() {\n    try {\n      this.setState({\n        collapsing: true\n      });\n\n      setTimeout(() => {\n        this.setState((state, props) => ({\n          collapsed: !state.collapsed,\n          collapsing: false\n        }));\n      }, 350);\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n  }\n\n  async download() {\n    try {\n      let data = await service.readAll();\n      let dataUrl =\n          \"data:text/json;charset=utf8,\" +\n          encodeURIComponent(JSON.stringify(data)),\n        aDownload = document.getElementById(\"downloadDummy\");\n\n      aDownload.setAttribute(\"href\", dataUrl);\n      aDownload.setAttribute(\"download\", \"data.json\");\n\n      aDownload.click();\n    } catch (error) {\n      this.setState({\n        errors: [error]\n      });\n    }\n  }\n\n  render() {\n    let style = {},\n      btnBack;\n    try {\n      btnBack =\n        this.props.history.length &&\n        this.props.history.location.pathname !== \"/\" ? (\n          <button\n            className=\"btn btn-link\"\n            onClick={() => this.props.history.goBack()}\n          >\n            Zurück{\" \"}\n          </button>\n        ) : null;\n\n      if (this.state.collapsed) {\n        style.height = this.state.height;\n      }\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n    return (\n      <div className=\"row\">\n        <div className=\"col\">\n          <nav className=\"navbar navbar-expand-lg navbar-light bg-light\">\n            <Link className=\"navbar-brand\" to=\"/\">\n              {this.props.title}\n            </Link>\n            <button\n              onClick={this.toggleMenu}\n              className={\n                this.state.collapsed\n                  ? \"navbar-toggler collapsed\"\n                  : \"navbar-toggler\"\n              }\n              type=\"button\"\n              data-toggle=\"collapse\"\n              data-target=\"#navbarSupportedContent\"\n              aria-controls=\"navbarSupportedContent\"\n              aria-expanded={this.state.collapsed ? \"false\" : \"true\"}\n              aria-label=\"Toggle navigation\"\n            >\n              <span className=\"navbar-toggler-icon\" />\n            </button>\n\n            <div\n              className={\n                this.state.collapsing\n                  ? \"navbar-collapse collapsing\"\n                  : this.state.collapsed\n                  ? \"navbar-collapse collapse\"\n                  : \"navbar-collapse collapse show\"\n              }\n              {...style}\n              id=\"navbarSupportedContent\"\n            >\n              <ul\n                className=\"navbar-nav mr-auto\"\n                ref={divElement => {\n                  this.divElement = divElement;\n                }}\n              >\n                <li className=\"nav-item\">\n                  <Link className=\"nav-link\" to=\"/teams\">\n                    Vereine\n                  </Link>\n                </li>\n                <li className=\"nav-item\">\n                  <Link className=\"nav-link\" to=\"/matches\">\n                    Spiele\n                  </Link>\n                </li>\n                <li className=\"nav-item\">\n                  <a className=\"nav-link\" onClick={this.download}>\n                    Exportieren\n                  </a>\n                  <a id=\"downloadDummy\" style={{ display: \"none\" }} />\n                </li>\n              </ul>\n            </div>\n          </nav>\n          {btnBack}\n          <Alert messages={this.state.errors} />\n        </div>\n      </div>\n    );\n  }\n}\n","C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\Select.js",[],"C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\Alert.js",[],"C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\FormGroup.js",[],"C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\Service.js",["64"],"class Service {\n  constructor() {\n    this.data = {\n      teams: [\n        {\n          id: 1,\n          name: \"Mönchen Gladbach\"\n        },\n        {\n          id: 2,\n          name: \"1. FC Köln\"\n        },\n        {\n          id: 3,\n          name: \"Bayer Leverkusen\"\n        },\n        {\n          id: 4,\n          name: \"FC Bayern\"\n        },\n        {\n          id: 5,\n          name: \"Schalke\"\n        },\n        {\n          id: 6,\n          name: \"Vfb\"\n        },\n        {\n          id: 7,\n          name: \"Freiburg\"\n        },\n        {\n          id: 8,\n          name: \"SGE\"\n        },\n        {\n          id: 9,\n          name: \"Arminia\"\n        }\n      ],\n      matches: [\n        {\n          id: 1,\n          host: {\n            id: 4,\n            goals: 8,\n            name: \"FC Bayern\"\n          },\n          guest: {\n            id: 5,\n            goals: 0,\n            name: \"Schalke\"\n          },\n          gameDay: \"2020-01-01\"\n        },\n        {\n          id: 2,\n          host: {\n            id: 6,\n            goals: 2,\n            name: \"Vfb\"\n          },\n          guest: {\n            id: 7,\n            goals: 3,\n            name: \"Freiburg\"\n          },\n          gameDay: \"2020-02-01\"\n        },\n        {\n          id: 3,\n          host: {\n            id: 8,\n            goals: 1,\n            name: \"SGE\"\n          },\n          guest: {\n            id: 9,\n            goals: 1,\n            name: \"Arminia\"\n          },\n          gameDay: \"2020-03-01\"\n        }\n      ]\n    };\n\n    this.metadata = {\n      paths: [\n        {\n          name: \"/team/:id\",\n          type: \"team\",\n          collection: \"teams\"\n        },\n        {\n          name: \"/teams\",\n          type: \"team\",\n          sort: this.sortTeams,\n          collection: \"teams\"\n        },\n        {\n          name: \"/match/:id\",\n          type: \"match\",\n          validate: this.validateMatch,\n          collection: \"matches\"\n        },\n        {\n          name: \"/matches\",\n          type: \"match\",\n          sort: this.sortMatch,\n          collection: \"matches\"\n        }\n      ],\n      types: [\n        {\n          name: \"match\",\n          properties: [\n            {\n              name: \"id\",\n              type: \"number\",\n              label: \"#\",\n              isKey: true,\n              autoIncrement: true\n            },\n            {\n              name: \"gameDay\",\n              type: \"date\",\n              label: \"Spieltag\",\n              required: true\n            },\n            {\n              name: \"host\",\n              type: \"participant\",\n              label: \"Gastgeber\",\n              required: true,\n              valueList: {\n                path: \"/teams\",\n                id: \"id\",\n                value: \"name\"\n              }\n            },\n            {\n              name: \"guest\",\n              type: \"participant\",\n              label: \"Gast\",\n              required: true,\n              valueList: {\n                path: \"/teams\",\n                id: \"id\",\n                value: \"name\"\n              }\n            }\n          ]\n        },\n        {\n          name: \"team\",\n          form: [\n            {\n              path: \"name\",\n              meta: \"/team/name\",\n              type: \"TextBox\"\n            }\n          ],\n          properties: [\n            {\n              name: \"$uri\",\n              value: \"/team/{id}\"\n            },\n            {\n              name: \"id\",\n              type: \"number\",\n              label: \"#\",\n              isKey: true,\n              autoIncrement: true\n            },\n            {\n              name: \"name\",\n              type: \"string\",\n              label: \"Name\",\n              isName: true,\n              required: true\n            }\n          ]\n        },\n        {\n          name: \"participant\",\n          properties: [\n            {\n              name: \"id\",\n              type: \"number\",\n              required: true\n            },\n            {\n              name: \"name\",\n              type: \"string\",\n              required: true\n            },\n            {\n              name: \"goals\",\n              type: \"number\",\n              label: \"Tore\",\n              min: 0,\n              required: true\n            }\n          ]\n        }\n      ]\n    };\n/*\n    this.batch = [];\n    this.interrupt = 0;\n    this.pending = 0;\n    this.executeBatch = this.executeBatch.bind(this);*/\n  }\n\n  /*startBatch() {\n    if (!this.pending) {\n      this.pending = setTimeout(this.executeBatch, this.interrupt);\n    }\n  }\n\n  executeBatch() {\n    this.batch.forEach(batchRequest => {\n      try {\n        batchRequest.resolve(result);\n      } catch (e) {\n        batchRequest.reject(e);\n      }\n    });\n  }*/\n\n  post() {}\n\n  createEntity(path, data) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.batch.push({\n          method: \"post\",\n          path: path,\n          resolve: resolve,\n          reject: reject\n        });\n        this.startBatch();\n\n        let metadataPath = this.getMetaPath(path),\n          collection = this.getCollection(path, metadataPath);\n\n        if (!path) {\n          throw new Error(\"Pfad nicht angegeben\");\n        }\n\n        this.determineEntity(metadataPath, collection, \"create\", data);\n        this.validateEntity(metadataPath, collection, \"create\", data);\n\n        collection.push(Object.assign({}, data));\n        resolve(data);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  readEntity(path) {\n    return new Promise((resolve, reject) => {\n      try {\n        let metadataPath = this.getMetaPath(path),\n          collection = this.getCollection(path, metadataPath);\n\n        if (!path) {\n          throw new Error(\"Pfad nicht angegeben\");\n        }\n\n        let result = collection.find(entity =>\n          this.entityEquals(path, metadataPath, entity)\n        );\n\n        if (result) {\n          resolve(Object.assign({}, result));\n        } else {\n          let e = new Error(`Entität nicht gefunden`);\n          e.httpStatus = 401.\n          throw e;\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  readEntities(path) {\n    return new Promise((resolve, reject) => {\n      try {\n        let metadataPath = this.getMetaPath(path),\n          collection = this.getCollection(path, metadataPath);\n\n        if (!path) {\n          throw new Error(\"Pfad nicht angegeben\");\n        }\n\n        let result = collection.filter(entity =>\n          this.entityEquals(path, metadataPath, entity)\n        );\n\n        if (result && !result.length) {\n          resolve(result);\n        }\n\n        if (metadataPath.sort) {\n          result = result.sort(metadataPath.sort);\n        }\n\n        resolve(result.map(entity => Object.assign({}, entity)));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  metaRecursiv(metadata, parts) {\n    if (!parts.length) {\n      return metadata;\n    }\n    let property = metadata.properties.find(\n      property => property.name === parts[0]\n    );\n\n    if (parts.length === 1) {\n      return property;\n    } else {\n      let type = this.metadata.type.find(type => type.name === property.type);\n      parts.splice(1);\n\n      if (!type) {\n        throw new Error(`Pfad \"${parts[0]}\" nicht auflösbar`);\n      } else {\n        return this.metaRecursiv(type, parts);\n      }\n    }\n  }\n\n  readMetadata(path) {\n    return new Promise((resolve, reject) => {\n      try {\n        let parts = path.split(\"/\").filter(part => part),\n          result;\n        if (!parts.length) {\n          throw new Error(\"Metadatenpfad nicht angegeben\");\n        }\n\n        result = this.metadata.types.find(type => type.name === parts[0]);\n        if (!result) {\n          throw new Error(`Pfad \"${parts[0]}\" konnte nicht aufgelöst werden`);\n        }\n\n        result = this.metaRecursiv(result, parts.splice(1));\n\n        resolve(result);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  updateEntity(path, data) {\n    return new Promise((resolve, reject) => {\n      try {\n        let metadataPath = this.getMetaPath(path),\n          collection = this.getCollection(path, metadataPath);\n\n        if (!path) {\n          throw new Error(\"Pfad nicht angegeben\");\n        }\n\n        let result = collection.find(entity =>\n          this.entityEquals(path, metadataPath, entity)\n        );\n\n        if (result) {\n          Object.assign(result, data);\n\n          this.determineEntity(metadataPath, collection, \"update\", result);\n          this.validateEntity(metadataPath, collection, \"update\", result);\n\n          resolve(Object.assign({}, result));\n        } else {\n          let e = new Error('Nicht gefunden');\n          e.httpStatus = 401.\n          throw e;\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  deleteEntity(path) {\n    return new Promise((resolve, reject) => {\n      try {\n        let metadataPath = this.getMetaPath(path),\n          collection = this.getCollection(path, metadataPath);\n\n        if (!path) {\n          throw new Error(\"Pfad nicht angegeben\");\n        }\n\n        let result = collection.find(entity =>\n          this.entityEquals(path, metadataPath, entity)\n        );\n\n        if (result) {\n          let index = collection.indexOf(result);\n\n          collection.splice(index, 1);\n          resolve();\n        } else {\n          let e = new Error('Nicht gefunden');\n          e.httpStatus = 401.\n          throw e;\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  getMetaPath(path) {\n    return this.metadata.paths.find(metaPath => {\n      // /team/:id\n      let metaRegex = metaPath.name.replace(/:\\w+/g, \"([^/]+)\"),\n        matches = path.match(metaRegex),\n        paramMatches = metaPath.name.match(/:\\w+/g);\n      // /team/([^/]+)\n      // [ \"/team/:id\", \":id\" ]\n      // [ \":id\" ]\n\n      //Filter auf untypisierten Regex fehlgeschlagen\n      if (!matches || !matches.length) {\n        return false;\n      }\n\n      if (!paramMatches) {\n        //keine parameter vorhanden\n        return true;\n      }\n\n      // typisierten Regex erstellen\n      metaRegex = metaPath.name;\n      paramMatches.forEach(match => {\n        let type = this.metadata.types.find(\n          type => type.name === metaPath.type\n        );\n\n        let property = type.properties.find(property => {\n            return property.name === match.substring(1);\n          }),\n          paramRegex;\n        switch (property.type) {\n          case \"number\":\n            paramRegex = \"([0-9]+)\";\n            break;\n\n          case \"string\":\n            paramRegex = \"([^/]+)\";\n        }\n        metaRegex = metaRegex.replace(\":\" + property.name, paramRegex);\n      });\n\n      // gegen typisiertes Regex testen\n      matches = path.match(metaRegex);\n\n      //Filter auf typisierten Regex\n      if (!matches || !matches.length) {\n        return false;\n      }\n\n      return matches[0] === path;\n    });\n  }\n\n  getCollection(path, metadataPath) {\n    if (!metadataPath) {\n      let e = new Error(`Ressource \"${path}\" nicht gefunden`);\n      e.httpStatus = 401.\n      throw e;\n    }\n\n    return this.data[metadataPath.collection];\n  }\n\n  entityEquals(path, metadataPath, entity) {\n    //Pfad aus der Entität erstellen udn mit dem übergebenen Pfad abgleichen\n    let type = this.metadata.types.find(\n        type => type.name === metadataPath.type\n      ),\n      entityPath = metadataPath.name;\n\n    // Wenn keine Parameter definiert ist, dann ist alles ein Treffer\n    if (metadataPath.name.search(\":\") === -1) {\n      return true;\n    }\n\n    type.properties.forEach(\n      property =>\n        (entityPath = entityPath.replace(\n          \":\" + property.name,\n          entity[property.name]\n        ))\n    );\n\n    return path === entityPath;\n  }\n\n  determineEntity(metadataPath, collection, operation, data) {\n    let type = this.metadata.types.find(\n        type => type.name === metadataPath.type\n      ),\n      uri = type.properties.find(property => property.name === \"$uri\").value;\n    alert(uri);\n\n    type.properties.forEach(\n      property =>\n        (uri = uri.replace(\"{\" + property.name + \"}\", data[property.name]))\n    );\n    data[\"$uri\"] = uri;\n\n    if (operation === \"create\") {\n      type.properties.forEach(property => {\n        if (property.autoIncrement) {\n          let maxValue = -1;\n\n          collection.forEach(entity => {\n            maxValue =\n              entity[property.name] > maxValue\n                ? entity[property.name]\n                : maxValue;\n          });\n\n          data[property.name] = ++maxValue;\n        }\n      });\n    }\n\n    if (type.determine) {\n      type.determine(metadataPath, collection, operation, data);\n    }\n  }\n\n  validateProperties(property, data, error) {\n    error.errors = error.errors ?? [];\n\n    if (property.required && !data[property.name]) {\n      let e = new Error(\"Das ist ein Pflichtfeld\");\n      e.field = property.name;\n      error.errors.push(e);\n    }\n\n    //rekursiver Aufruf für die Validierung\n    if (this.metadata.types[property.type] && data[property.name]) {\n      let type = this.metadata.types[property.type];\n\n      type.properties.forEach(property =>\n        this.validateProperties(property, data[property.name], error)\n      );\n    }\n  }\n\n  validateEntity(metadataPath, collection, operation, data) {\n    let error = new Error(),\n      type = this.metadata.types.find(type => type.name === metadataPath.type);\n\n    type.properties.forEach(property =>\n      this.validateProperties(property, data, error)\n    );\n\n    switch (error.errors.length) {\n      case 0:\n        break;\n      case 1:\n        throw error.errors[0];\n      default:\n        throw error;\n    }\n\n    if (type.validate) {\n      type.validate(metadataPath, collection, operation, data);\n    }\n  }\n\n  sortTeams(team1, team2) {\n    if (team1.name > team2.name) {\n      return 1;\n    }\n    if (team1.name < team2.name) {\n      return -1;\n    }\n\n    return 0;\n  }\n\n  validateMatch(metadataPath, collection, operation, data) {\n    if (data.host.id === data.guest.id) {\n      let e = new Error(\"Wählen Sie zwei unterschiedliche Teams aus\");\n      e.field = \"guest.id\";\n      throw e;\n    }\n  }\n\n  sortMatch(a, b) {\n    if (a.gameDay > b.gameDay) {\n      return 1;\n    }\n    if (a.gameDay < b.gameDay) {\n      return -1;\n    }\n    if (a.host.name > b.host.name) {\n      return 1;\n    }\n    if (a.guest.name < b.guest.name) {\n      return -1;\n    }\n\n    return 0;\n  }\n\n  readAll() {\n    return new Promise((resolve, reject) => {\n      resolve(this.data);\n    });\n  }\n}\n\nconst service = new Service();\n\nexport default service;\n",["65","66"],"C:\\Users\\rm\\dev\\projects\\soccer-oracle\\app\\src\\Setup.js",[],{"ruleId":"67","severity":1,"message":"68","line":25,"column":27,"nodeType":"69","messageId":"70","endLine":25,"endColumn":32},{"ruleId":"67","severity":1,"message":"71","line":26,"column":15,"nodeType":"69","messageId":"70","endLine":26,"endColumn":19},{"ruleId":"72","replacedBy":"73"},{"ruleId":"74","replacedBy":"75"},{"ruleId":"76","severity":1,"message":"77","line":73,"column":33,"nodeType":"78","messageId":"79","endLine":73,"endColumn":35},{"ruleId":"80","severity":1,"message":"81","line":144,"column":19,"nodeType":"82","endLine":144,"endColumn":67},{"ruleId":"83","severity":1,"message":"84","line":147,"column":19,"nodeType":"82","endLine":147,"endColumn":71},{"ruleId":"80","severity":1,"message":"81","line":147,"column":19,"nodeType":"82","endLine":147,"endColumn":71},{"ruleId":"85","severity":1,"message":"86","line":457,"column":9,"nodeType":"87","messageId":"88","endLine":464,"endColumn":10},{"ruleId":"72","replacedBy":"89"},{"ruleId":"74","replacedBy":"90"},"no-unused-vars","'teams' is defined but never used.","Identifier","unusedVar","'sort' is assigned a value but never used.","no-native-reassign",["91"],"no-negated-in-lhs",["92"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","jsx-a11y/anchor-has-content","Anchors must have content and the content must be accessible by a screen reader.","default-case","Expected a default case.","SwitchStatement","missingDefaultCase",["91"],["92"],"no-global-assign","no-unsafe-negation"]