[{"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\index.js":"1","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\NotFound.js":"2","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\App.js":"3","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\serviceWorker.js":"4","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Form.js":"5","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Alert.js":"6","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\PageHeader.js":"7","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Input.js":"8","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Select.js":"9","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Table.js":"10","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Service.js":"11","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\FormGroup.js":"12"},{"size":773,"mtime":1607404546587,"results":"13","hashOfConfig":"14"},{"size":100,"mtime":1606895122868,"results":"15","hashOfConfig":"14"},{"size":2586,"mtime":1607459394438,"results":"16","hashOfConfig":"14"},{"size":4951,"mtime":1606895122891,"results":"17","hashOfConfig":"14"},{"size":336,"mtime":1606895122862,"results":"18","hashOfConfig":"14"},{"size":644,"mtime":1607077009745,"results":"19","hashOfConfig":"14"},{"size":4059,"mtime":1606917451254,"results":"20","hashOfConfig":"14"},{"size":1063,"mtime":1607078537216,"results":"21","hashOfConfig":"14"},{"size":1412,"mtime":1607460029727,"results":"22","hashOfConfig":"14"},{"size":3645,"mtime":1606895122880,"results":"23","hashOfConfig":"14"},{"size":14501,"mtime":1607078066967,"results":"24","hashOfConfig":"14"},{"size":660,"mtime":1606895122863,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"1gcy4v2",{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"28"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"28"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"45"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"28"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\index.js",[],["57","58"],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\NotFound.js",[],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\App.js",["59"],"import React from \"react\";\nimport PageHeader from \"./PageHeader\";\nimport Alert from \"./Alert\";\nimport Form from \"./Form\";\nimport Select from \"./Select\";\n\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      teams: [],\n      team1: {},\n      team2: {},\n      errors: []\n    };\n\n    this.onSubmit = this.onSubmit.bind(this);\n    this.onSelectTeam = this.onSelectTeam.bind(this);\n  }\n\n  async componentDidMount() {\n    try {\n      let response, teams, error;\n\n      response = await fetch(\"/api/teams\");\n\n      if (response.status === 200) {\n        teams = await response.json();\n\n        this.setState({\n          teams: teams\n        });\n\n      } else {\n        error = await response.text();\n        throw new Error(error);\n      }\n\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n\n    }\n  }\n\n  onSelectTeam(event) {\n    try {\n      if (event.target.id === \"cmbTeam1\") {\n        this.setState({\n          team1: this.state.teams.find(team => team.TeamId === +event.target.value)\n        });\n      } else {\n        this.setState({\n          team2: this.state.teams.find(team => team.TeamId === +event.target.value)\n        });\n      }\n\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n  }\n\n  onSubmit(event) {\n    event.preventDefault();\n\n    if (this.state.team1.TeamId === this.state.team2.TeamId) {\n      const message = \"Wählen Sie unterschiedliche Teams\";\n      let e = new Error(message),\n        errors = [e];\n\n      e.field = \"team1\";\n\n      e = new Error(message)\n      e.field = \"team2\";\n      errors.push(e);\n\n      this.setState({\n        errors: errors\n      });\n    }\n  }\n\n  render() {\n    let teams = this.state.teams.map(team => ({\n      id: team.TeamId,\n      value: team.TeamName\n    }));\n\n    return (\n      <div>\n        <PageHeader history={this.props.history} title=\"Startseite\" />\n        <Form onSubmit={this.onSubmit} errors={this.state.errors}>\n          <Select\n            id=\"cmbTeam1\"\n            required={true}\n            onChange={this.onSelectTeam}\n            value={this.state.team1.TeamId}\n            errors={this.state.errors.filter(error => error.field === 'team1')}\n            options={teams}\n          />\n          <Select\n            id=\"cmbTeam2\"\n            required={true}\n            onChange={this.onSelectTeam}\n            value={this.state.team2.TeamId}\n            options={teams}\n            errors={this.state.errors.filter(error => error.field === 'team2')}\n            />\n        </Form>\n      </div>\n    );\n  }\n}\n","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\serviceWorker.js",[],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Form.js",[],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Alert.js",[],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\PageHeader.js",["60","61","62"],"import React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport Alert from \"./Alert\";\nimport service from \"./Service\";\n\nexport default class PageHeader extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      collapsed: true,\n      collapsing: false,\n      errors: []\n    };\n\n    this.toggleMenu = this.toggleMenu.bind(this);\n  }\n\n  componentDidMount() {\n    try {\n      this.setState({\n        height: this.divElement.clientHeight\n      });\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n  }\n\n  toggleMenu() {\n    try {\n      this.setState({\n        collapsing: true\n      });\n\n      setTimeout(() => {\n        this.setState((state, props) => ({\n          collapsed: !state.collapsed,\n          collapsing: false\n        }));\n      }, 350);\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n  }\n\n  async download() {\n    try {\n      let data = await service.readAll();\n      let dataUrl =\n          \"data:text/json;charset=utf8,\" +\n          encodeURIComponent(JSON.stringify(data)),\n        aDownload = document.getElementById(\"downloadDummy\");\n\n      aDownload.setAttribute(\"href\", dataUrl);\n      aDownload.setAttribute(\"download\", \"data.json\");\n\n      aDownload.click();\n    } catch (error) {\n      this.setState({\n        errors: [error]\n      });\n    }\n  }\n\n  render() {\n    let style = {},\n      btnBack;\n    try {\n      btnBack =\n        this.props.history.length &&\n        this.props.history.location.pathname !== \"/\" ? (\n          <button\n            className=\"btn btn-link\"\n            onClick={() => this.props.history.goBack()}\n          >\n            Zurück{\" \"}\n          </button>\n        ) : null;\n\n      if (this.state.collapsed) {\n        style.height = this.state.height;\n      }\n    } catch (e) {\n      this.setState({\n        errors: [e]\n      });\n    }\n    return (\n      <div className=\"row\">\n        <div className=\"col\">\n          <nav className=\"navbar navbar-expand-lg navbar-light bg-light\">\n            <Link className=\"navbar-brand\" to=\"/\">\n              {this.props.title}\n            </Link>\n            <button\n              onClick={this.toggleMenu}\n              className={\n                this.state.collapsed\n                  ? \"navbar-toggler collapsed\"\n                  : \"navbar-toggler\"\n              }\n              type=\"button\"\n              data-toggle=\"collapse\"\n              data-target=\"#navbarSupportedContent\"\n              aria-controls=\"navbarSupportedContent\"\n              aria-expanded={this.state.collapsed ? \"false\" : \"true\"}\n              aria-label=\"Toggle navigation\"\n            >\n              <span className=\"navbar-toggler-icon\" />\n            </button>\n\n            <div\n              className={\n                this.state.collapsing\n                  ? \"navbar-collapse collapsing\"\n                  : this.state.collapsed\n                  ? \"navbar-collapse collapse\"\n                  : \"navbar-collapse collapse show\"\n              }\n              {...style}\n              id=\"navbarSupportedContent\"\n            >\n              <ul\n                className=\"navbar-nav mr-auto\"\n                ref={divElement => {\n                  this.divElement = divElement;\n                }}\n              >\n                <li className=\"nav-item\">\n                  <Link className=\"nav-link\" to=\"/teams\">\n                    Vereine\n                  </Link>\n                </li>\n                <li className=\"nav-item\">\n                  <Link className=\"nav-link\" to=\"/matches\">\n                    Spiele\n                  </Link>\n                </li>\n                <li className=\"nav-item\">\n                  <a className=\"nav-link\" onClick={this.download}>\n                    Exportieren\n                  </a>\n                  <a id=\"downloadDummy\" style={{ display: \"none\" }} />\n                </li>\n              </ul>\n            </div>\n          </nav>\n          {btnBack}\n          <Alert messages={this.state.errors} />\n        </div>\n      </div>\n    );\n  }\n}\n","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Input.js",[],["63","64"],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Select.js",[],"C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Table.js",["65"],"import React from \"react\";\n\nexport default class Table extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      selection: {}\n    };\n\n    this.toggleSelection = this.toggleSelection.bind(this);\n    this.delete = this.delete.bind(this);\n  }\n\n  toggleSelection(event) {\n    let newState = {\n      selection: Object.assign({}, this.state.selection)\n    };\n\n    newState.selection[event.target.id] = {};\n\n    if (\n      this.state.selection[event.target.id] &&\n      this.state.selection[event.target.id].selected\n    ) {\n      delete newState.selection[event.target.id];\n    } else {\n      newState.selection[event.target.id].selected = true;\n    }\n\n    this.setState(newState);\n  }\n\n  delete() {\n    let toDeleteIds = [],\n      toDeleteItems = [];\n\n    let keys = Object.keys(this.state.selection);\n\n    keys.forEach(key => {\n      if (this.state.selection[key].selected) {\n        toDeleteIds.push(+key);\n        toDeleteItems.push(this.props.rows.find(item => item.id === +key));\n      }\n    });\n\n    this.props.delete(toDeleteIds, toDeleteItems).then(() => {\n      this.setState({\n        selection: {}\n      });\n    });\n  }\n\n  getContent(row, column) {\n    let value;\n\n    if (column.type === \"date\") {\n      value = new Date(row[column.name]).toLocaleDateString();\n    } else if (typeof column.name === \"function\") {\n      value = column.name(row);\n    } else {\n      value = row[column.name];\n    }\n\n    let content = column.navigation ? (\n      <a id={row.id.toString()} onClick={column.navigation} href=\"#\">\n        {value}\n      </a>\n    ) : (\n      value\n    );\n\n    if (column.name === \"id\") {\n      return (\n        <th id={row.id.toString()} scope=\"row\" key={column.id}>\n          {content}\n        </th>\n      );\n    } else {\n      return (\n        <td id={row.id.toString()} key={column.id}>\n          {content}\n        </td>\n      );\n    }\n  }\n\n  render() {\n    let rows = !this.props.rows ? (\n      <tr>\n        <td colSpan={this.props.columns.length} className=\"text-center\">keine Daten</td>\n      </tr>\n    ) : (\n      this.props.rows &&\n      this.props.rows.map(row => {\n        let selected =\n            this.state.selection[row.id.toString()] &&\n            this.state.selection[row.id.toString()].selected,\n          attributes = {\n            className: selected ? \"table-danger\" : \"\"\n          };\n\n        let cells =\n          this.props.columns &&\n          this.props.columns.map(column => this.getContent(row, column));\n\n        return (\n          <tr\n            {...attributes}\n            key={row.id.toString()}\n            onClick={this.toggleSelection}\n          >\n            {cells}\n          </tr>\n        );\n      })\n    );\n    return (\n      <table className=\"table table-bordered table-hover\">\n        <thead>\n          <tr>\n            <th colSpan={this.props.columns.length + 1} className=\"text-right\">\n              <button className=\"btn btn-secondary\" onClick={this.props.create}>\n                Neu\n              </button>\n              <button\n                className=\"btn btn-danger\"\n                onClick={this.delete}\n                disabled={Object.keys(this.state.selection).length === 0}\n              >\n                Löschen\n              </button>\n            </th>\n          </tr>\n          <tr>\n            {this.props.columns &&\n              this.props.columns.map(column => {\n                return (\n                  <th key={column.id} scope=\"col\">\n                    {column.label}\n                  </th>\n                );\n              })}\n          </tr>\n        </thead>\n        <tbody>{rows}</tbody>\n      </table>\n    );\n  }\n}\n","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\Service.js",["66"],"class Service {\n  constructor() {\n    this.data = {\n      teams: [\n        {\n          id: 1,\n          name: \"Mönchen Gladbach\"\n        },\n        {\n          id: 2,\n          name: \"1. FC Köln\"\n        },\n        {\n          id: 3,\n          name: \"Bayer Leverkusen\"\n        },\n        {\n          id: 4,\n          name: \"FC Bayern\"\n        },\n        {\n          id: 5,\n          name: \"Schalke\"\n        },\n        {\n          id: 6,\n          name: \"Vfb\"\n        },\n        {\n          id: 7,\n          name: \"Freiburg\"\n        },\n        {\n          id: 8,\n          name: \"SGE\"\n        },\n        {\n          id: 9,\n          name: \"Arminia\"\n        }\n      ],\n      matches: [\n        {\n          id: 1,\n          host: {\n            id: 4,\n            goals: 8,\n            name: \"FC Bayern\"\n          },\n          guest: {\n            id: 5,\n            goals: 0,\n            name: \"Schalke\"\n          },\n          gameDay: \"2020-01-01\"\n        },\n        {\n          id: 2,\n          host: {\n            id: 6,\n            goals: 2,\n            name: \"Vfb\"\n          },\n          guest: {\n            id: 7,\n            goals: 3,\n            name: \"Freiburg\"\n          },\n          gameDay: \"2020-02-01\"\n        },\n        {\n          id: 3,\n          host: {\n            id: 8,\n            goals: 1,\n            name: \"SGE\"\n          },\n          guest: {\n            id: 9,\n            goals: 1,\n            name: \"Arminia\"\n          },\n          gameDay: \"2020-03-01\"\n        }\n      ]\n    };\n\n    this.metadata = {\n      paths: [\n        {\n          name: \"/team/:id\",\n          type: \"team\",\n          collection: \"teams\"\n        },\n        {\n          name: \"/teams\",\n          type: \"team\",\n          sort: this.sortTeams,\n          collection: \"teams\"\n        },\n        {\n          name: \"/match/:id\",\n          type: \"match\",\n          validate: this.validateMatch,\n          collection: \"matches\"\n        },\n        {\n          name: \"/matches\",\n          type: \"match\",\n          sort: this.sortMatch,\n          collection: \"matches\"\n        }\n      ],\n      types: [\n        {\n          name: \"match\",\n          properties: [\n            {\n              name: \"id\",\n              type: \"number\",\n              label: \"#\",\n              isKey: true,\n              autoIncrement: true\n            },\n            {\n              name: \"gameDay\",\n              type: \"date\",\n              label: \"Spieltag\",\n              required: true\n            },\n            {\n              name: \"host\",\n              type: \"participant\",\n              label: \"Gastgeber\",\n              required: true,\n              valueList: {\n                path: \"/teams\",\n                id: \"id\",\n                value: \"name\"\n              }\n            },\n            {\n              name: \"guest\",\n              type: \"participant\",\n              label: \"Gast\",\n              required: true,\n              valueList: {\n                path: \"/teams\",\n                id: \"id\",\n                value: \"name\"\n              }\n            }\n          ]\n        },\n        {\n          name: \"team\",\n          form: [\n            {\n              path: \"name\",\n              meta: \"/team/name\",\n              type: \"TextBox\"\n            }\n          ],\n          properties: [\n            {\n              name: \"$uri\",\n              value: \"/team/{id}\"\n            },\n            {\n              name: \"id\",\n              type: \"number\",\n              label: \"#\",\n              isKey: true,\n              autoIncrement: true\n            },\n            {\n              name: \"name\",\n              type: \"string\",\n              label: \"Name\",\n              isName: true,\n              required: true\n            }\n          ]\n        },\n        {\n          name: \"participant\",\n          properties: [\n            {\n              name: \"id\",\n              type: \"number\",\n              required: true\n            },\n            {\n              name: \"name\",\n              type: \"string\",\n              required: true\n            },\n            {\n              name: \"goals\",\n              type: \"number\",\n              label: \"Tore\",\n              min: 0,\n              required: true\n            }\n          ]\n        }\n      ]\n    };\n/*\n    this.batch = [];\n    this.interrupt = 0;\n    this.pending = 0;\n    this.executeBatch = this.executeBatch.bind(this);*/\n  }\n\n  /*startBatch() {\n    if (!this.pending) {\n      this.pending = setTimeout(this.executeBatch, this.interrupt);\n    }\n  }\n\n  executeBatch() {\n    this.batch.forEach(batchRequest => {\n      try {\n        batchRequest.resolve(result);\n      } catch (e) {\n        batchRequest.reject(e);\n      }\n    });\n  }*/\n\n  post() {}\n\n  createEntity(path, data) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.batch.push({\n          method: \"post\",\n          path: path,\n          resolve: resolve,\n          reject: reject\n        });\n        this.startBatch();\n\n        let metadataPath = this.getMetaPath(path),\n          collection = this.getCollection(path, metadataPath);\n\n        if (!path) {\n          throw new Error(\"Pfad nicht angegeben\");\n        }\n\n        this.determineEntity(metadataPath, collection, \"create\", data);\n        this.validateEntity(metadataPath, collection, \"create\", data);\n\n        collection.push(Object.assign({}, data));\n        resolve(data);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  readEntity(path) {\n    return new Promise((resolve, reject) => {\n      try {\n        let metadataPath = this.getMetaPath(path),\n          collection = this.getCollection(path, metadataPath);\n\n        if (!path) {\n          throw new Error(\"Pfad nicht angegeben\");\n        }\n\n        let result = collection.find(entity =>\n          this.entityEquals(path, metadataPath, entity)\n        );\n\n        if (result) {\n          resolve(Object.assign({}, result));\n        } else {\n          let e = new Error(`Entität nicht gefunden`);\n          e.httpStatus = 401.\n          throw e;\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  readEntities(path) {\n    return new Promise((resolve, reject) => {\n      try {\n        let metadataPath = this.getMetaPath(path),\n          collection = this.getCollection(path, metadataPath);\n\n        if (!path) {\n          throw new Error(\"Pfad nicht angegeben\");\n        }\n\n        let result = collection.filter(entity =>\n          this.entityEquals(path, metadataPath, entity)\n        );\n\n        if (result && !result.length) {\n          resolve(result);\n        }\n\n        if (metadataPath.sort) {\n          result = result.sort(metadataPath.sort);\n        }\n\n        resolve(result.map(entity => Object.assign({}, entity)));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  metaRecursiv(metadata, parts) {\n    if (!parts.length) {\n      return metadata;\n    }\n    let property = metadata.properties.find(\n      property => property.name === parts[0]\n    );\n\n    if (parts.length === 1) {\n      return property;\n    } else {\n      let type = this.metadata.type.find(type => type.name === property.type);\n      parts.splice(1);\n\n      if (!type) {\n        throw new Error(`Pfad \"${parts[0]}\" nicht auflösbar`);\n      } else {\n        return this.metaRecursiv(type, parts);\n      }\n    }\n  }\n\n  readMetadata(path) {\n    return new Promise((resolve, reject) => {\n      try {\n        let parts = path.split(\"/\").filter(part => part),\n          result;\n        if (!parts.length) {\n          throw new Error(\"Metadatenpfad nicht angegeben\");\n        }\n\n        result = this.metadata.types.find(type => type.name === parts[0]);\n        if (!result) {\n          throw new Error(`Pfad \"${parts[0]}\" konnte nicht aufgelöst werden`);\n        }\n\n        result = this.metaRecursiv(result, parts.splice(1));\n\n        resolve(result);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  updateEntity(path, data) {\n    return new Promise((resolve, reject) => {\n      try {\n        let metadataPath = this.getMetaPath(path),\n          collection = this.getCollection(path, metadataPath);\n\n        if (!path) {\n          throw new Error(\"Pfad nicht angegeben\");\n        }\n\n        let result = collection.find(entity =>\n          this.entityEquals(path, metadataPath, entity)\n        );\n\n        if (result) {\n          Object.assign(result, data);\n\n          this.determineEntity(metadataPath, collection, \"update\", result);\n          this.validateEntity(metadataPath, collection, \"update\", result);\n\n          resolve(Object.assign({}, result));\n        } else {\n          let e = new Error('Nicht gefunden');\n          e.httpStatus = 401.\n          throw e;\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  deleteEntity(path) {\n    return new Promise((resolve, reject) => {\n      try {\n        let metadataPath = this.getMetaPath(path),\n          collection = this.getCollection(path, metadataPath);\n\n        if (!path) {\n          throw new Error(\"Pfad nicht angegeben\");\n        }\n\n        let result = collection.find(entity =>\n          this.entityEquals(path, metadataPath, entity)\n        );\n\n        if (result) {\n          let index = collection.indexOf(result);\n\n          collection.splice(index, 1);\n          resolve();\n        } else {\n          let e = new Error('Nicht gefunden');\n          e.httpStatus = 401.\n          throw e;\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  getMetaPath(path) {\n    return this.metadata.paths.find(metaPath => {\n      // /team/:id\n      let metaRegex = metaPath.name.replace(/:\\w+/g, \"([^/]+)\"),\n        matches = path.match(metaRegex),\n        paramMatches = metaPath.name.match(/:\\w+/g);\n      // /team/([^/]+)\n      // [ \"/team/:id\", \":id\" ]\n      // [ \":id\" ]\n\n      //Filter auf untypisierten Regex fehlgeschlagen\n      if (!matches || !matches.length) {\n        return false;\n      }\n\n      if (!paramMatches) {\n        //keine parameter vorhanden\n        return true;\n      }\n\n      // typisierten Regex erstellen\n      metaRegex = metaPath.name;\n      paramMatches.forEach(match => {\n        let type = this.metadata.types.find(\n          type => type.name === metaPath.type\n        );\n\n        let property = type.properties.find(property => {\n            return property.name === match.substring(1);\n          }),\n          paramRegex;\n        switch (property.type) {\n          case \"number\":\n            paramRegex = \"([0-9]+)\";\n            break;\n\n          case \"string\":\n            paramRegex = \"([^/]+)\";\n        }\n        metaRegex = metaRegex.replace(\":\" + property.name, paramRegex);\n      });\n\n      // gegen typisiertes Regex testen\n      matches = path.match(metaRegex);\n\n      //Filter auf typisierten Regex\n      if (!matches || !matches.length) {\n        return false;\n      }\n\n      return matches[0] === path;\n    });\n  }\n\n  getCollection(path, metadataPath) {\n    if (!metadataPath) {\n      let e = new Error(`Ressource \"${path}\" nicht gefunden`);\n      e.httpStatus = 401.\n      throw e;\n    }\n\n    return this.data[metadataPath.collection];\n  }\n\n  entityEquals(path, metadataPath, entity) {\n    //Pfad aus der Entität erstellen udn mit dem übergebenen Pfad abgleichen\n    let type = this.metadata.types.find(\n        type => type.name === metadataPath.type\n      ),\n      entityPath = metadataPath.name;\n\n    // Wenn keine Parameter definiert ist, dann ist alles ein Treffer\n    if (metadataPath.name.search(\":\") === -1) {\n      return true;\n    }\n\n    type.properties.forEach(\n      property =>\n        (entityPath = entityPath.replace(\n          \":\" + property.name,\n          entity[property.name]\n        ))\n    );\n\n    return path === entityPath;\n  }\n\n  determineEntity(metadataPath, collection, operation, data) {\n    let type = this.metadata.types.find(\n        type => type.name === metadataPath.type\n      ),\n      uri = type.properties.find(property => property.name === \"$uri\").value;\n    alert(uri);\n\n    type.properties.forEach(\n      property =>\n        (uri = uri.replace(\"{\" + property.name + \"}\", data[property.name]))\n    );\n    data[\"$uri\"] = uri;\n\n    if (operation === \"create\") {\n      type.properties.forEach(property => {\n        if (property.autoIncrement) {\n          let maxValue = -1;\n\n          collection.forEach(entity => {\n            maxValue =\n              entity[property.name] > maxValue\n                ? entity[property.name]\n                : maxValue;\n          });\n\n          data[property.name] = ++maxValue;\n        }\n      });\n    }\n\n    if (type.determine) {\n      type.determine(metadataPath, collection, operation, data);\n    }\n  }\n\n  validateProperties(property, data, error) {\n    error.errors = error.errors ?? [];\n\n    if (property.required && !data[property.name]) {\n      let e = new Error(\"Das ist ein Pflichtfeld\");\n      e.field = property.name;\n      error.errors.push(e);\n    }\n\n    //rekursiver Aufruf für die Validierung\n    if (this.metadata.types[property.type] && data[property.name]) {\n      let type = this.metadata.types[property.type];\n\n      type.properties.forEach(property =>\n        this.validateProperties(property, data[property.name], error)\n      );\n    }\n  }\n\n  validateEntity(metadataPath, collection, operation, data) {\n    let error = new Error(),\n      type = this.metadata.types.find(type => type.name === metadataPath.type);\n\n    type.properties.forEach(property =>\n      this.validateProperties(property, data, error)\n    );\n\n    switch (error.errors.length) {\n      case 0:\n        break;\n      case 1:\n        throw error.errors[0];\n      default:\n        throw error;\n    }\n\n    if (type.validate) {\n      type.validate(metadataPath, collection, operation, data);\n    }\n  }\n\n  sortTeams(team1, team2) {\n    if (team1.name > team2.name) {\n      return 1;\n    }\n    if (team1.name < team2.name) {\n      return -1;\n    }\n\n    return 0;\n  }\n\n  validateMatch(metadataPath, collection, operation, data) {\n    if (data.host.id === data.guest.id) {\n      let e = new Error(\"Wählen Sie zwei unterschiedliche Teams aus\");\n      e.field = \"guest.id\";\n      throw e;\n    }\n  }\n\n  sortMatch(a, b) {\n    if (a.gameDay > b.gameDay) {\n      return 1;\n    }\n    if (a.gameDay < b.gameDay) {\n      return -1;\n    }\n    if (a.host.name > b.host.name) {\n      return 1;\n    }\n    if (a.guest.name < b.guest.name) {\n      return -1;\n    }\n\n    return 0;\n  }\n\n  readAll() {\n    return new Promise((resolve, reject) => {\n      resolve(this.data);\n    });\n  }\n}\n\nconst service = new Service();\n\nexport default service;\n","C:\\Users\\yx00857\\dev\\projects\\soccer-oracle\\app\\src\\FormGroup.js",[],["67","68"],{"ruleId":"69","replacedBy":"70"},{"ruleId":"71","replacedBy":"72"},{"ruleId":"73","severity":1,"message":"74","line":3,"column":8,"nodeType":"75","messageId":"76","endLine":3,"endColumn":13},{"ruleId":"77","severity":1,"message":"78","line":144,"column":19,"nodeType":"79","endLine":144,"endColumn":67},{"ruleId":"80","severity":1,"message":"81","line":147,"column":19,"nodeType":"79","endLine":147,"endColumn":71},{"ruleId":"77","severity":1,"message":"78","line":147,"column":19,"nodeType":"79","endLine":147,"endColumn":71},{"ruleId":"69","replacedBy":"82"},{"ruleId":"71","replacedBy":"83"},{"ruleId":"77","severity":1,"message":"84","line":66,"column":7,"nodeType":"79","endLine":66,"endColumn":70},{"ruleId":"85","severity":1,"message":"86","line":457,"column":9,"nodeType":"87","messageId":"88","endLine":464,"endColumn":10},{"ruleId":"69","replacedBy":"89"},{"ruleId":"71","replacedBy":"90"},"no-native-reassign",["91"],"no-negated-in-lhs",["92"],"no-unused-vars","'Alert' is defined but never used.","Identifier","unusedVar","jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","jsx-a11y/anchor-has-content","Anchors must have content and the content must be accessible by a screen reader.",["91"],["92"],"The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","default-case","Expected a default case.","SwitchStatement","missingDefaultCase",["91"],["92"],"no-global-assign","no-unsafe-negation"]